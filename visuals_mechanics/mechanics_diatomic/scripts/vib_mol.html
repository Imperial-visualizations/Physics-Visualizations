<!doctype html>
<head>
    <title>Diatomic Molecule Vibration and Rotation</title>
    <script src = "https://github.com/photonstorm/phaser-ce/releases/download/v2.8.3/phaser.min.js"></script>
    <script src = "./vecops.js"></script>
    <script src = "./potentials.js"></script>
</head>

<div id="physics"></div>
<script>
    /** ============================================ Class Declarations ==============================================*/
    /**
     * Class to describe attributes of atoms that can be used to make up molecules.
     * @param pos: Vector with Cartesian position coordinates
     * @param radius: Radius of atom.
     * @param mass: Mass of atom.
     * @param potential: Object defining potential type at atom (e.g. LJ, harmonic, etc.)
     * @param color: Color of atom for phaser code.(cosmetic only)
     * @constructor: Atom
     */
    Atom = function(pos, radius, mass, potential, color) {
        // Making position and force vectors.
        this.pos = new Vector(pos);                 // Atom position Vector.

        // Checking for unphysical parameters.
        if (radius <= 0 || mass <= 0) {
            console.error("Unphysical system detected! Please check radius, mass and charge values.");

            // Correcting to physical values.
            radius = -radius;
            mass = -mass;
        }
        this.color = color;
        this.r = radius;                            // Atom radius.
        this.m = mass;                              // Atom mass.
        this.sprite = addAtom(this);
        this.V = potential;                         // Setting potential centre of atom.
        this.p = 0;                                 // Momentum of atom initially 0.
    };

    /**
     * Class to make molecule out of atoms, with a spring constant that defines strength of bonds, and instantiated with
     * rotational and vibrational E.
     * @param atoms: Array containing all atoms in molecules.
     * @param vibrational_E: Vibrational kinetic energy.
     * @param rotational_E: Rotational kinetic energy.
     * @constructor
     */
    Molecule = function(atoms, vibrational_E, rotational_E) {

        // Checking objects of class Atom passed in in the list.
        if (atoms.constructor === Array || atoms[0].constructor === Atom)
        {
            this.atoms = atoms;                                                             // Atoms
            // Calculating scalar distance between atoms.
            this.r = new Vector(this.atoms[0].pos.subtract(this.atoms[1].pos)).mag();      // Atom separation.
            this.COM = this.calcCOM();                                      // Centre of mass initialised as 0 vector.
        }

        // Finding total mass of the system.
        this.tot_m = function () {
            var m = 0;
            for (var i = 0; i < this.atoms.length; i++) {
                m += this.atoms[i].m;
            }
            return m
        };

        // Finding system's reduced mass.
        this.reducedM = function () {
            var muInv = 0;
            for(var i = 0; i < this.atoms.length;i++){
                muInv += 1/this.atoms.m;
            }
            return 1/muInv;
        };

        this.elasped = 0;
        this.I = this.calcMoI();                                            // Moment of inertia initialised as 0.
        this.E_v = vibrational_E;                                           // Vibrational energy.
        this.E_r = rotational_E;                                            // Rotational energy.
        this.PE = this.calcPE();                                            // Potential energy.
        this.Lsq = 2 * rotational_E * this.I;                               // Square of Angular Momentum.

        // Magnitude of linear momentum for each Atom object.
        this.p_i = Math.sqrt((this.E_r * 2 * this.tot_m) / (Math.pow(this.atoms.length, 2)));
        for (var i = 0; i < this.atoms.length; i++) {
            this.atoms[i].p = this.p_i;                                     // Setting each atom's momentum.
        }

    };


    /** =============================================== Class Methods ================================================*/
    /**
     * Calculates the scalar distance between a pair of atoms.
     * @param atom1: Atom
     * @param atom2: Another atom
     * @returns {number} separation, r.
     */
    Molecule.prototype.calcSeparation = function(atom1, atom2) {
        var r = atom1.pos.subtract(atom2.pos);
        return new Vector(r).mag();
    };

    /**
     * Calculates the unit vector between two atom positions.
     * @param atom1: Atom
     * @param atom2: Another atom
     * @returns {Vector} Unit vector
     */
    Molecule.prototype.calcUnitVect = function(atom1, atom2) {
        var r = atom1.pos.subtract(atom2.pos);
        return new Vector(r).unit();
    };

    /**
     * Calculates the potential energy of the system using the potential functions instantiated to each atom.
     * @returns {Number} System PE.
     */
    Molecule.prototype.calcPE = function() {
        var pot_energy = 0;                                                         // Potential energy.

        // Pairwise potential calculation.
        for (var i = 0; i < this.atoms.length; i++) {
            for (var j = 0; j < this.atoms.length; j++) {
                // Avoiding calculating potential between the same atom (r = 0, V --> inf)
                if (i !== j) {
                    var r = this.calcSeparation(this.atoms[i], this.atoms[j]);      // Scalar distance between atoms.
                    pot_energy += this.atoms[i].V.calcV(r);                         // Calculating potential energy.
                }
            }
        }
        this.PE = pot_energy;
        return this.PE;
    };
    /**
     * @returns {Number} Current value of the rotational kinetic energy of the system.
     *
     */
    Molecule.prototype.calcRotKE = function() {
        return this.Lsq/(2*this.I);


    };

    /**
     * Updates coordinates of atoms after rotation about COM.
     * @param t: Timestep
     * @returns {Array} List of atoms in molecule after rotation around COM.
     */
    Molecule.prototype.calcRotCoords = function(t) {
        // E_r = 0.5 * I * w ** 2
        var w = Math.sqrt(2 * this.E_r / this.I);                                 // Angular velocity, w
        var d_Angle = w * t;                                                      // Rotation angle around COM (radians)

        // Rotation of atoms about COM.
        for (var i = 0; i < this.atoms.length; i++)
        {
            this.atoms[i].pos = this.atoms[i].pos.subtract(this.COM);            // Find atom coords with COM at Origin
            this.atoms[i].pos = new Vector(this.atoms[i].pos.rotate(d_Angle));   // Updating atoms coords after rotation
            this.atoms[i].pos = this.atoms[i].pos.add(this.COM);                 // Moving COM back to original coords
        }

        return this.atoms
    };

    /**
     * Calculates Moment of Inertia.
     * @returns {number} I
     */
    Molecule.prototype.calcMoI = function() {
        var I = 0;                                                          // Moment of Inertia.
        for (var i = 0; i < this.atoms.length; i++) {                       // Distance between this atom and COM.
            var r_i = new Vector(this.atoms[i].pos.subtract(this.COM));     // Distance between this atom and COM
            I += this.atoms[i].m * Math.pow(r_i.mag(), 2);                  // m*r**2 contribution for this atom.
            console.log(I);
        }
        return I                                                            // Return Moment of Inertia (scalar).
    };

    /**
     * Calculates Centre of Mass coordinates.
     * @returns {Vector} Centre of Mass
     */
    Molecule.prototype.calcCOM = function() {
        var total_m = 0;                                                    // Total mass of system.

        var total_mx = [];                                                  // Total mass * position (mx) of system.
        for (var j = 0; j < this.atoms[0].pos.items.length; j++) {
            total_mx.push(0)
        }
        total_mx = new Vector(total_mx);                                    // mx initialised as 0 vector.

        // Summing mx and m.
        for (var i = 0; i < this.atoms.length; i++) {
            total_m += this.atoms[i].m;
            var mx = new Vector(this.atoms[i].pos.multiply(this.atoms[i].m));
            total_mx = new Vector(total_mx.add(mx));
        }

        this.COM = new Vector(total_mx.multiply(1 / total_m));              // Updating instance COM coords.
        return this.COM;                                                    // Return Vector coordinates of COM.
    };

//    /**
//     * @param elapsed: time that the molecule has been alive for
//     * @param deltaTime: time passed between this frame and last frame important for incrementing physics.
//     */
//
//    Molecule.prototype.calculateDisplacement = function(deltaTime,elapsed){
//        var amplitude = Math.sqrt(2*this.E_v/kval);
//        var natFreq = Math.sqrt(kVal / this.reducedM);
//        var dx = -1 * amplitude * Math.sin(natFreq*elapsed) * deltaTime;
//        //get seperation vector and subtract dx*unitvector in direction of sep vector to create oscillation.
//        var r_i_new = calcSeperation() - calcUnitVector() * dx;
//
//    };

    /**
     * Function to calculate extended coordinates due to vibrational energy.
     * @param dT: Time elapsed since previous timestep.
     */
    Molecule.prototype.calcExtCoords = function (dT) {

        var s = [];                                               // Array to store new coordinates.
        for (var i = 0; i < this.atoms.length; i++) {
            for (var j = 0; j < this.atoms.length; i++) {
                if (i !== j) {
                    var r = new Vector(this.atoms[i].pos.subtract(this.atoms[j]));        // Vector to other atom.
                    var dir = new Vector(r.unit());               // Unit vector to other atom

                    var f_s = this.atoms[i].V.calcF(r.mag());     // Scalar Force on atom[j] due to atom[i]

                    var a = f_s * (1 / this.atoms[j].m);          // Acceleration scalar: F=ma
                    var u = this.atoms[j].p / this.atoms[j].m;    // Old scalar velocity of atom: p = m * u
                    var v = u + (a.mag() * dT);                   // New scalar velocity: v = u + at
                    var s_s = (Math.pow(v, 2) - Math.pow(u, 2)) / (2 * a.mag());          // Scalar displacement.
                    s.push(dir.multiply(new Vector(s_s)));        // Vector displacement pushed to array.
                }
            }
        }

        // Calculating new coords for each atom.
        for (var k = 0; k < this.atoms.length; i++) {
            this.atoms[k].pos = this.atoms[k].pos.add(s[k]);
        }
        return s
    };

    /**
     * Function that performs physics calculation at a fixed rate (usually 60FPS), in here the relevant values
     * for the next frame should be calculated.
     * @param deltaTime : time passed between this frame and the last frame for incrementing physics.
     */
    Molecule.prototype.update = function(deltaTime) {
        this.elasped += deltaTime;
        calcRotCoords(deltaTime,elapsed);
        //TODO: Calculate the vibration amplitude given the vibrational KE
        //TODO: Update position due to vibrational motion.
        //TODO: Update position due to rotational motion.
        //TODO: Check if vibrational energy greater than restoring energy (Hooke's Law)

    };
</script>

<div id="phaser"></div>
<script src="./graphics.js"></script>
<body>

</body>